#' api_key <- "User123"
#' market_date <- get.marketDate (code=code, start_date=start_date, end_date=end_date, collapse=collapse, api_key=api_key)
#' }
#' @note Due to Quandle database specification, all ".", " " symbols are represented as "_".
#' @references This R package uses the Quandl API. For more information go to \url{https://www.quandl.com/docs/api}. For more help on the package itself go to \url{https://www.quandl.com/help/r}.
#' @export
get.marketData <- function(code, start_date, end_date,
collapse=c("daily", "weekly", "monthly", "quarterly", "annual"),
api_key) {
# check if code is correct
if (!all(gsub("[^A-Z0-9_.]", "", code) == code)) {
stop("Codes are comprised of capital letters, numbers and underscores only.")
}
params <- list()
params$collapse <- match.arg(collapse)
params$start_date <- as.Date(start_date, format = "%Y-%m-%d")
params$end_date <- as.Date(end_date, format = "%Y-%m-%d")
params$end_date <- end_date
params$api_key <- api_key
params$column_index <- 11
params$transform <- "rdiff"
for (c in code) {
df <- get.dataset(c, params)
if (!exists("res")) {
res <- df
} else {
res <- merge(res, df, by = 1, all = TRUE)
}
}
row.names(res) <- res$date
res$date <- NULL
return(res)
}
get.dataset <- function(code, params) {
writeLines(sprintf("Calling %s data...", code))
json <- api.call(url_base=sprintf("https://www.quandl.com/api/v3/datasets/WIKI/%s/data.json?", code),
params=params)$dataset
if (length(json$data) == 0) {
stop(sprintf("Data for %s between %s and %s (%s) does not exists.",
code, params$start_date, params$end_date, params$collapse))
}
data <- data.frame(json$data, stringsAsFactors = FALSE)
names(data) <- c("date", code)
data[, 1] <- as.Date(data[, 1])
data[, 2] <- as.numeric(data[, 2])
return(data)
}
api.call <- function(url_base, params) {
response <- httr::GET(url_base, query=params, timeout(60))
if (!(httr::status_code(response) >= 200 && httr::status_code(response) < 300)) {
stop(httr::content(response, as = "text"), call. = FALSE)
}
text_response <- httr::content(response, as = "text")
json_response <- tryCatch(jsonlite::fromJSON(text_response, simplifyVector = TRUE), error = function(e) {
stop(e, " Failed to parse response: ", text_response)
})
return(json_response)
}
token <- "jS1u13So85xPZ2Mi7Z5x"
code <- c("AAPL", "FB", "GOOG", "C", "IBS MY ASSERT")
start_date <- "2016-12-31"
end_date <- "2018-12-31"
collapse <- "daily"
fin_data <- get.marketData(code=code, start_date = start_date, end_date = end_date,
collapse = "weekly", api_key = token)
#' End of day US Stock Proces
#'
#' Retrieves Data from the Quandl Dataset endpoint and formats
#' @param code string or list of strings: Code a.k.a ticker symbol on Quandle.
#' @param start_date A Date object, format="YYYY-MM-DD". Retrieve data rows on and after the specified start date.
#' @param end_date A Date object, format="YYYY-MM-DD". Retrieve data rows up to and including the specified end date.
#' @param collapse Change the sampling frequency of the returned data. Default is none; i.e., data is returned in its original granularity.
#' @param api_key Authentication toket for a Quandl user.
#' @return dataframe of returns per stock
#' @examples \dontrun{
#' code <- c("AAPL", "FB", "GOOG", "C", "A", "INTC", "T", "WMT", "TXN")
#' start_date <- "2017-12-31"
#' end_date <- "2018-12-31"
#' collapse <- "daily"
#' api_key <- "User123"
#' market_date <- get.marketDate (code=code, start_date=start_date, end_date=end_date, collapse=collapse, api_key=api_key)
#' }
#' @note Due to Quandle database specification, all ".", " " symbols are represented as "_".
#' @references This R package uses the Quandl API. For more information go to \url{https://www.quandl.com/docs/api}. For more help on the package itself go to \url{https://www.quandl.com/help/r}.
#' @export
get.marketData <- function(code, start_date, end_date,
collapse=c("daily", "weekly", "monthly", "quarterly", "annual"),
api_key) {
# check if code is correct
if (!all(gsub("[^A-Z0-9_.]", "", code) == code)) {
stop("Codes are comprised of capital letters, numbers and underscores only.")
}
params <- list()
params$collapse <- match.arg(collapse)
params$start_date <- as.Date(start_date, format = "%Y-%m-%d")
params$end_date <- as.Date(end_date, format = "%Y-%m-%d")
params$end_date <- end_date
params$api_key <- api_key
params$column_index <- 11
params$transform <- "rdiff"
for (c in code) {
df <- get.dataset(c, params)
if (!exists("res")) {
res <- df
} else {
res <- merge(res, df, by = 1, all = TRUE)
}
}
row.names(res) <- res$date
res$date <- NULL
return(res)
}
get.dataset <- function(code, params) {
writeLines(sprintf("Calling %s data...", code))
json <- api.call(url_base=sprintf("https://www.quandl.com/api/v3/datasets/WIKI/%s/data.json?", code),
params=params)$dataset
if (length(json$data) == 0) {
stop(sprintf("Data for %s between %s and %s (%s) does not exists.",
code, params$start_date, params$end_date, params$collapse))
}
data <- data.frame(json$data, stringsAsFactors = FALSE)
names(data) <- c("date", code)
data[, 1] <- as.Date(data[, 1])
data[, 2] <- as.numeric(data[, 2])
return(data)
}
api.call <- function(url_base, params) {
response <- httr::GET(url_base, query=params, timeout(60))
if (!(httr::status_code(response) >= 200 && httr::status_code(response) < 300)) {
stop(httr::content(response, as = "text"), call. = FALSE)
}
text_response <- httr::content(response, as = "text")
json_response <- tryCatch(jsonlite::fromJSON(text_response, simplifyVector = TRUE), error = function(e) {
stop(e, " Failed to parse response: ", text_response)
})
return(json_response)
}
token <- "jS1u13So85xPZ2Mi7Z5x"
code <- c("AAPL", "FB", "GOOG", "C")
start_date <- "1976-12-31"
end_date <- "1977-12-31"
collapse <- "daily"
fin_data <- get.marketData(code=code, start_date = start_date, end_date = end_date,
collapse = "weekly", api_key = token)
#' End of day US Stock Proces
#'
#' Retrieves Data from the Quandl Dataset endpoint and formats
#' @param code string or list of strings: Code a.k.a ticker symbol on Quandle.
#' @param start_date A Date object, format="YYYY-MM-DD". Retrieve data rows on and after the specified start date.
#' @param end_date A Date object, format="YYYY-MM-DD". Retrieve data rows up to and including the specified end date.
#' @param collapse Change the sampling frequency of the returned data. Default is none; i.e., data is returned in its original granularity.
#' @param api_key Authentication toket for a Quandl user.
#' @return dataframe of returns per stock
#' @examples \dontrun{
#' code <- c("AAPL", "FB", "GOOG", "C", "A", "INTC", "T", "WMT", "TXN")
#' start_date <- "2017-12-31"
#' end_date <- "2018-12-31"
#' collapse <- "daily"
#' api_key <- "User123"
#' market_date <- get.marketDate (code=code, start_date=start_date, end_date=end_date, collapse=collapse, api_key=api_key)
#' }
#' @note Due to Quandle database specification, all ".", " " symbols are represented as "_".
#' @references This R package uses the Quandl API. For more information go to \url{https://www.quandl.com/docs/api}. For more help on the package itself go to \url{https://www.quandl.com/help/r}.
#' @export
get.marketData <- function(code, start_date, end_date,
collapse=c("daily", "weekly", "monthly", "quarterly", "annual"),
api_key) {
# check if code is correct
if (!all(gsub("[^A-Z0-9_.]", "", code) == code)) {
stop("Codes are comprised of capital letters, numbers and underscores only.")
}
params <- list()
params$collapse <- match.arg(collapse)
params$start_date <- as.Date(start_date, format = "%Y-%m-%d")
params$end_date <- as.Date(end_date, format = "%Y-%m-%d")
params$end_date <- end_date
params$api_key <- api_key
params$column_index <- 11
params$transform <- "rdiff"
for (c in code) {
df <- get.dataset(c, params)
if (!exists("res")) {
res <- df
} else {
res <- merge(res, df, by = 1, all = TRUE)
}
}
row.names(res) <- res$date
res$date <- NULL
return(res)
}
get.dataset <- function(code, params) {
writeLines(sprintf("Calling %s data...", code))
json <- api.call(url_base=sprintf("https://www.quandl.com/api/v3/datasets/WIKI/%s/data.json?", code),
params=params)$dataset
if (length(json$data) == 0) {
stop(sprintf("Data for %s between %s and %s (%s) does not exists.",
code, params$start_date, params$end_date, params$collapse))
}
data <- data.frame(json$data, stringsAsFactors = FALSE)
names(data) <- c("date", code)
data[, 1] <- as.Date(data[, 1])
data[, 2] <- as.numeric(data[, 2])
return(data)
}
api.call <- function(url_base, params) {
response <- httr::GET(url_base, query=params, timeout(60))
if (!(httr::status_code(response) >= 200 && httr::status_code(response) < 300)) {
stop(httr::content(response, as = "text"), call. = FALSE)
}
text_response <- httr::content(response, as = "text")
json_response <- tryCatch(jsonlite::fromJSON(text_response, simplifyVector = TRUE), error = function(e) {
stop(e, " Failed to parse response: ", text_response)
})
return(json_response)
}
token <- "jS1u13So85xPZ2Mi7Z5x"
code <- c("AAPL", "FB", "GOOG", "C")
start_date <- "-1976-12-31"
end_date <- "-1977-12-31"
collapse <- "daily"
fin_data <- get.marketData(code=code, start_date = start_date, end_date = end_date,
collapse = "weekly", api_key = token)
fin_data
library(optimx)
setwd("/Users/kirylkhamutou/Downloads/")
options(digits = 8)
calcPortfolioPerf <- function(weights, meanReturns, covMatrix) {
portReturn <- Reduce('+', Map('*', meanReturns, weights))
portStdDev <- sqrt(t(weights) %*% (covMatrix %*% weights))
return(c(portReturn, portStdDev))
}
negSharpeRatio <- function(weights, meanReturns, covMatrix, riskFreeRate) {
# portPref <- calcPortfolioPerf(weights, meanReturns, covMatrix)
p_ret <- Reduce('+', Map('*', meanReturns, weights))
p_var <- sqrt(t(weights) %*% (covMatrix %*% weights))
return (-(p_ret - riskFreeRate) / p_var)
}
getPortfolioVol <- function(weights, meanReturns, covMatrix) {
return (calcPortfolioPerf(weights, meanReturns, covMatrix)[2])
}
findMaxSharpeRatioPortfolio <- function(meanReturns, covMatrix, riskFreeRate) {
numAssets <- length(meanReturns)
params <- c(meanReturns, covMatrix, riskFreeRate)
opts <- optim(rep(1/numAssets, numAssets), negSharpeRatio, method = "L-BFGS-B",
control=list(trace=1),
meanReturns=meanReturns, covMatrix=covMatrix, riskFreeRate=riskFreeRate,
lower=rep(0, numAssets), upper=rep(1, numAssets))
return(opts$par / sum(opts$par))
}
stocks <- read.csv2("/Users/kirylkhamutou/Downloads/Data.csv",header = TRUE)
stocks$Date <- as.Date(stocks$Date, format = "%d.%m.%Y")
stocks <- stocks[order(stocks$Date), ]
f <- stocks
for (i in 2:ncol(f)) {
prices = f[,i]
prices_prev = c(NA,prices[1:(length(prices)-1)])
returns = (prices-prices_prev)/prices_prev
f[,i] = returns
}
returns <- fin_data
rm(f, i, prices, prices_prev)
meanReturns <- lapply(returns, mean)
covMatrix <- cov(returns)
weights <- rep(0.2, 5)
riskFreeRate <- 0
maxSharpe <- findMaxSharpeRatioPortfolio(meanReturns = meanReturns,
covMatrix = covMatrix,
riskFreeRate = riskFreeRate)
# [1] 0.331871070 0.074127527 0.539151538 0.054849865 0.000000000
# [1] 0.331870634 0.074128962 0.539149011 0.054851394 0.000000000
maxSharpe
fin_data
View(fin_data)
View(fin_data)
lapply(fin_data, mean)
covMatrix
maxSharpe
data.class(maxSharpe, colnames = names(covMatrix))
data.class(maxSharpe, colnames = names(meanReturns))
getPortfolioVol(weights, meanReturns, covMatrix)
getPortfolioVol(weights, meanReturns$AAPL, covMatrix)
calcPortfolioPerf(weights, meanReturns, covMatrix)
meanReturns
weights <- rep(0.2, ncol(meanReturns))
weights <- rep(0.2, 3)
calcPortfolioPerf(weights, meanReturns, covMatrix)
fin_data
weights <- rep(0.2, 4)
calcPortfolioPerf(weights, meanReturns, covMatrix)
sqrt(t(.25) %*% (cov(fin_data$AAPL) %*% .25))
cov(fin_data$AAPL)
library(optimx)
setwd("/Users/kirylkhamutou/Downloads/")
options(digits = 8)
calcPortfolioPerf <- function(weights, meanReturns, covMatrix) {
portReturn <- Reduce('+', Map('*', meanReturns, weights))
portStdDev <- sqrt(t(weights) %*% (covMatrix %*% weights))
return(c(portReturn, portStdDev))
}
negSharpeRatio <- function(weights, meanReturns, covMatrix, riskFreeRate) {
# portPref <- calcPortfolioPerf(weights, meanReturns, covMatrix)
p_ret <- Reduce('+', Map('*', meanReturns, weights))
p_var <- sqrt(t(weights) %*% (covMatrix %*% weights))
return (-(p_ret - riskFreeRate) / p_var)
}
getPortfolioVol <- function(weights, meanReturns, covMatrix) {
return (calcPortfolioPerf(weights, meanReturns, covMatrix)[2])
}
findMaxSharpeRatioPortfolio <- function(meanReturns, covMatrix, riskFreeRate) {
numAssets <- length(meanReturns)
params <- c(meanReturns, covMatrix, riskFreeRate)
opts <- optim(rep(1/numAssets, numAssets), negSharpeRatio, method = "L-BFGS-B",
control=list(trace=1),
meanReturns=meanReturns, covMatrix=covMatrix, riskFreeRate=riskFreeRate,
lower=rep(0, numAssets), upper=rep(1, numAssets))
return(opts$par / sum(opts$par))
}
stocks <- read.csv2("/Users/kirylkhamutou/Downloads/Data.csv",header = TRUE)
stocks$Date <- as.Date(stocks$Date, format = "%d.%m.%Y")
stocks <- stocks[order(stocks$Date), ]
f <- stocks
for (i in 2:ncol(f)) {
prices = f[,i]
prices_prev = c(NA,prices[1:(length(prices)-1)])
returns = (prices-prices_prev)/prices_prev
f[,i] = returns
}
returns <- fin_data
rm(f, i, prices, prices_prev)
meanReturns <- lapply(returns, mean)
covMatrix <- cov(returns)
weights <- rep(0.25, 4)
riskFreeRate <- 0
maxSharpe <- findMaxSharpeRatioPortfolio(meanReturns = meanReturns,
covMatrix = covMatrix,
riskFreeRate = riskFreeRate)
# [1] 0.331871070 0.074127527 0.539151538 0.054849865 0.000000000
# [1] 0.331870634 0.074128962 0.539149011 0.054851394 0.000000000
maxSharpe
sum(maxSharpe)
sqrt(fin_data$AAPL)
sd(fin_data$AAPL)
maxSharpe
lapply(fin_data, sd)
lapply(fin_data, mean)
lapply(fin_data, sd) / lapply(fin_data, mean)
mn <- lapply(fin_data, mean)
risk <- lapply(fin_data, sd)
c(mn) / c(risk)
mn$AAPL / risk$AAPL
mn$C / mn$C
mn$C / risk$C
mn$GOOG / risk$GOOG
#' End of day US Stock Proces
#'
#' Retrieves Data from the Quandl Dataset endpoint and formats
#' @param code string or list of strings: Code a.k.a ticker symbol on Quandle.
#' @param start_date A Date object, format="YYYY-MM-DD". Retrieve data rows on and after the specified start date.
#' @param end_date A Date object, format="YYYY-MM-DD". Retrieve data rows up to and including the specified end date.
#' @param collapse Change the sampling frequency of the returned data. Default is none; i.e., data is returned in its original granularity.
#' @param api_key Authentication toket for a Quandl user.
#' @return dataframe of returns per stock
#' @examples \dontrun{
#' code <- c("AAPL", "FB", "GOOG", "C", "A", "INTC", "T", "WMT", "TXN")
#' start_date <- "2017-12-31"
#' end_date <- "2018-12-31"
#' collapse <- "daily"
#' api_key <- "User123"
#' market_date <- get.marketDate (code=code, start_date=start_date, end_date=end_date, collapse=collapse, api_key=api_key)
#' }
#' @note Due to Quandle database specification, all ".", " " symbols are represented as "_".
#' @references This R package uses the Quandl API. For more information go to \url{https://www.quandl.com/docs/api}. For more help on the package itself go to \url{https://www.quandl.com/help/r}.
#' @export
get.marketData <- function(code, start_date, end_date,
collapse=c("daily", "weekly", "monthly", "quarterly", "annual"),
api_key) {
# check if code is correct
if (!all(gsub("[^A-Z0-9_.]", "", code) == code)) {
stop("Codes are comprised of capital letters, numbers and underscores only.")
}
params <- list()
params$collapse <- match.arg(collapse)
params$start_date <- as.Date(start_date, format = "%Y-%m-%d")
params$end_date <- as.Date(end_date, format = "%Y-%m-%d")
params$end_date <- end_date
params$api_key <- api_key
params$column_index <- 11
params$transform <- "rdiff"
for (c in code) {
df <- get.dataset(c, params)
if (!exists("res")) {
res <- df
} else {
res <- merge(res, df, by = 1, all = TRUE)
}
}
row.names(res) <- res$date
res$date <- NULL
return(res)
}
get.dataset <- function(code, params) {
writeLines(sprintf("Calling %s data...", code))
json <- api.call(url_base=sprintf("https://www.quandl.com/api/v3/datasets/WIKI/%s/data.json?", code),
params=params)$dataset
if (length(json$data) == 0) {
stop(sprintf("Data for %s between %s and %s (%s) does not exists.",
code, params$start_date, params$end_date, params$collapse))
}
data <- data.frame(json$data, stringsAsFactors = FALSE)
names(data) <- c("date", code)
data[, 1] <- as.Date(data[, 1])
data[, 2] <- as.numeric(data[, 2])
return(data)
}
api.call <- function(url_base, params) {
response <- httr::GET(url_base, query=params, timeout(60))
if (!(httr::status_code(response) >= 200 && httr::status_code(response) < 300)) {
stop(httr::content(response, as = "text"), call. = FALSE)
}
text_response <- httr::content(response, as = "text")
json_response <- tryCatch(jsonlite::fromJSON(text_response, simplifyVector = TRUE), error = function(e) {
stop(e, " Failed to parse response: ", text_response)
})
return(json_response)
}
token <- "jS1u13So85xPZ2Mi7Z5x"
code <- c("AAPL", "FB", "GOOG", "C")
start_date <- "2016-12-31"
end_date <- "2018-12-31"
collapse <- "daily"
fin_data <- get.marketData(code=code, start_date = start_date, end_date = end_date,
collapse = "weekly", api_key = token)
#' End of day US Stock Proces
#'
#' Retrieves Data from the Quandl Dataset endpoint and formats
#' @param code string or list of strings: Code a.k.a ticker symbol on Quandle.
#' @param start_date A Date object, format="YYYY-MM-DD". Retrieve data rows on and after the specified start date.
#' @param end_date A Date object, format="YYYY-MM-DD". Retrieve data rows up to and including the specified end date.
#' @param collapse Change the sampling frequency of the returned data. Default is none; i.e., data is returned in its original granularity.
#' @param api_key Authentication toket for a Quandl user.
#' @return dataframe of returns per stock
#' @examples \dontrun{
#' code <- c("AAPL", "FB", "GOOG", "C", "A", "INTC", "T", "WMT", "TXN")
#' start_date <- "2017-12-31"
#' end_date <- "2018-12-31"
#' collapse <- "daily"
#' api_key <- "User123"
#' market_date <- get.marketDate (code=code, start_date=start_date, end_date=end_date, collapse=collapse, api_key=api_key)
#' }
#' @note Due to Quandle database specification, all ".", " " symbols are represented as "_".
#' @references This R package uses the Quandl API. For more information go to \url{https://www.quandl.com/docs/api}. For more help on the package itself go to \url{https://www.quandl.com/help/r}.
#' @export
get.marketData <- function(code, start_date, end_date,
collapse=c("daily", "weekly", "monthly", "quarterly", "annual"),
api_key) {
# check if code is correct
if (!all(gsub("[^A-Z0-9_.]", "", code) == code)) {
stop("Codes are comprised of capital letters, numbers and underscores only.")
}
params <- list()
params$collapse <- match.arg(collapse)
params$start_date <- as.Date(start_date, format = "%Y-%m-%d")
params$end_date <- as.Date(end_date, format = "%Y-%m-%d")
params$end_date <- end_date
params$api_key <- api_key
params$column_index <- 11
params$transform <- "rdiff"
for (c in code) {
df <- get.dataset(c, params)
if (!exists("res")) {
res <- df
} else {
res <- merge(res, df, by = 1, all = TRUE)
}
}
row.names(res) <- res$date
res$date <- NULL
return(res)
}
get.dataset <- function(code, params) {
writeLines(sprintf("Calling %s data...", code))
json <- api.call(url_base=sprintf("https://www.quandl.com/api/v3/datasets/WIKI/%s/data.json?", code),
params=params)$dataset
if (length(json$data) == 0) {
stop(sprintf("Data for %s between %s and %s (%s) does not exists.",
code, params$start_date, params$end_date, params$collapse))
}
data <- data.frame(json$data, stringsAsFactors = FALSE)
names(data) <- c("date", code)
data[, 1] <- as.Date(data[, 1])
data[, 2] <- as.numeric(data[, 2])
return(data)
}
api.call <- function(url_base, params) {
response <- httr::GET(url_base, query=params, timeout(60))
if (!(httr::status_code(response) >= 200 && httr::status_code(response) < 300)) {
stop(httr::content(response, as = "text"), call. = FALSE)
}
text_response <- httr::content(response, as = "text")
json_response <- tryCatch(jsonlite::fromJSON(text_response, simplifyVector = TRUE), error = function(e) {
stop(e, " Failed to parse response: ", text_response)
})
return(json_response)
}
token <- "jS1u13So85xPZ2Mi7Z5x"
code <- c("AAPL", "FB", "GOOG", "C")
start_date <- "2016-12-31"
end_date <- "2018-12-31"
collapse <- "daily"
fin_data <- get.marketData(code=code, start_date = start_date, end_date = end_date,
collapse = "weekly", api_key = token)
