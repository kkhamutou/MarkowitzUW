#' @param skipNA If FALSE, STOP is a code for a predefined date range is not found, otherwise WARNIGN. Default=FALSE
#' @return list(data=dataframe of returns per stock, missingCode=vector of codes that do not satisfy input params)
#' @examples \dontrun{
#' code <- c("AAPL", "FB", "GOOG", "C", "A", "INTC", "T", "WMT", "TXN")
#' start_date <- "2017-12-31"
#' end_date <- "2018-12-31"
#' collapse <- "daily"
#' api_key <- "User123"s
#' market_date <- get.marketDate (code=code, start_date=start_date, end_date=end_date, collapse=collapse, api_key=api_key)
#' }
#' @note Due to Quandle database specification, all ".", " " symbols are represented as "_".
#' @references This R package uses the Quandl API. For more information go to \url{https://www.quandl.com/docs/api}. For more help on the package itself go to \url{https://www.quandl.com/help/r}.
#' @export
get.marketData <- function(code, start_date, end_date,
collapse=c("daily", "weekly", "monthly", "quarterly", "annual"),
api_key, skipNullStocks = FALSE, skipNA = FALSE) {
# check if code is correct
if (!all(gsub("[^A-Z0-9_.]", "", code) == code)) {
stop("Codes are comprised of capital letters, numbers and underscores only.")
}
# convert freq to interger. Used in skipNA=TRUE to validate if data.frame is of complete form.
frequency2integer <- function(freq) {
if (is.null(freq) || is.na(freq)) {
return(252)
} else {
switch(freq,
"daily"    = 252,
"weekly"   = 52,
"monthly"  = 12,
"quarterly" = 4,
"yearly"   = 1,
1)
}
}
# setup params for GET request
params <- list()
params$collapse <- match.arg(collapse)
params$start_date <- as.Date(start_date, format = "%Y-%m-%d")
params$end_date <- as.Date(end_date, format = "%Y-%m-%d")
params$end_date <- end_date
params$api_key <- api_key
params$column_index <- 11
params$transform <- "rdiff"
missingCodes <- c()
tempRes <- NULL
for (c in code) {
df <- get.dataset(c, params, skipNullStocks)
# check if a dataset has been found
if (is.null(df)) {
missingCodes <- append(missingCodes, c)
next()
}
# skipNA=TRUE, check if frequency of dataset returned is correct
if (!(length(df[, 2] & skipNA == TRUE) == frequency2integer(params$collapse))) {
missingCodes <- append(missingCodes, c)
next()
}
# merge data.frames
if (is.null(tempRes)) {
tempRes <- df
} else {
tempRes <- merge(tempRes, df, by = "date", all = TRUE)
}
}
return(list("data"=tempRes, "missingCodes"=missingCodes))
}
get.dataset <- function(code, params, skipNullStocks) {
writeLines(sprintf("Calling %s data...", code))
json <- api.call(url_base=sprintf("https://www.quandl.com/api/v3/datasets/WIKI/%s/data.json?", code),
params=params)$dataset
if (length(json$data) == 0) {
if (skipNullStocks == FALSE) {
stop(sprintf("Data for %s between %s and %s (%s) does not exists.",
code, params$start_date, params$end_date, params$collapse))
} else {
writeLines(sprintf("Data for %s between %s and %s (%s) does not exists.",
code, params$start_date, params$end_date, params$collapse))
return(NULL)
}
}
fin_data <- data.frame(json$data, stringsAsFactors = FALSE)
names(fin_data) <- c("date", code)
fin_data[, 1] <- as.Date(fin_data[, 1])
fin_data[, 2] <- as.numeric(fin_data[, 2])
return(fin_data)
}
api.call <- function(url_base, params) {
response <- httr::GET(url_base, query=params)
if (!(httr::status_code(response) >= 200 && httr::status_code(response) < 300)) {
stop(httr::content(response, as = "text"), call. = FALSE)
}
text_response <- httr::content(response, as = "text")
json_response <- tryCatch(jsonlite::fromJSON(text_response, simplifyVector = TRUE), error = function(e) {
stop(e, " Failed to parse response: ", text_response)
})
return(json_response)
}
get.marketData.random <- function(ncode, start_date, end_date,
collapse=c("daily", "weekly", "monthly", "quarterly", "annual"),
api_key, excludedCodes = NULL, skipNA = TRUE, recursive=FALSE) {
# Function needed for recursive option
recursive.helper <- function(df, codes.random, start_date, end_date, collapse, api_key) {
rec.data.random <- get.marketData(code = codes.random, start_date = start_date, end_date = end_date,
collapse = collapse, api_key = api_key, skipNA = skipNA, skipNullStocks = TRUE)
df <- tryCatch(
{
merge(df, rec.data.random$data, by="date", all = TRUE)
},
error=function(e) {
message(e)
message(names(rec.data.random$data))
message(names(df))
message(codes.random)
message(rec.data.random$missingCodes)
},
stop())
return(list("data"=df, "missingCodes"=rec.data.random$missingCodes))
}
# Remove codes that should not be included in sample
remove.codes.subset <- function(codes, codes2remove) {
return(subset(codes, !(codes %in% codes2remove)))
}
if (ncode > 299) {
stop("Max allowed number of requests is 299 per 10 seconds.")
}
codes <- read.table("metadata/tickers", header = TRUE, stringsAsFactors = FALSE)$code
codes <- remove.codes.subset(codes, excludedCodes)
codes.random <- sample(codes, ncode)
data.random <- get.marketData(code = codes.random, start_date = start_date, end_date = end_date,
collapse = collapse, api_key = api_key, skipNA = skipNA, skipNullStocks=TRUE)
# If none of stocks has been found - run the function again.
if (is.null(data.random$data)) {
get.marketData.random(ncode, start_date, end_date, collapse, api_key, excludedCodes, recursive)
}
if (is.null(data.random$missingCodes)) {
return(data.random)
}
if (recursive == TRUE) {
codes <- remove.codes.subset(codes, data.random$missingCodes)
codes.random <- sample(codes, length(data.random$missingCodes))
data.random$missingCodes <- NULL
while (TRUE) {
data.random <- recursive.helper(data.random$data, code = codes.random, start_date = start_date,
end_date = end_date, collapse = collapse, api_key = api_key)
if (!is.null(data.random$missingCodes)) {
codes <- remove.codes.subset(codes, data.random$missingCodes)
codes.random <- sample(codes, length(data.random$missingCodes))
} else {
return(data.random)
}
}
}
}
for (i in c(1:15)) {dt.rand <- get.marketData.random(10, start_date = start_date, end_date = end_date, collapse = "weekly", token, recursive = TRUE)
print(i)
}
#' End of day US Stock Proces
#'
#' Retrieves Data from the Quandl Dataset endpoint and formats
#' @param code string or list of strings: Code a.k.a ticker symbol on Quandle.
#' @param start_date A Date object, format="YYYY-MM-DD". Retrieve data rows on and after the specified start date.
#' @param end_date A Date object, format="YYYY-MM-DD". Retrieve data rows up to and including the specified end date.
#' @param collapse Change the sampling frequency of the returned data. Default is none; i.e., data is returned in its original granularity.
#' @param api_key Authentication toket for a Quandl user.
#' @param skipNA If FALSE, STOP is a code for a predefined date range is not found, otherwise WARNIGN. Default=FALSE
#' @return list(data=dataframe of returns per stock, missingCode=vector of codes that do not satisfy input params)
#' @examples \dontrun{
#' code <- c("AAPL", "FB", "GOOG", "C", "A", "INTC", "T", "WMT", "TXN")
#' start_date <- "2017-12-31"
#' end_date <- "2018-12-31"
#' collapse <- "daily"
#' api_key <- "User123"s
#' market_date <- get.marketDate (code=code, start_date=start_date, end_date=end_date, collapse=collapse, api_key=api_key)
#' }
#' @note Due to Quandle database specification, all ".", " " symbols are represented as "_".
#' @references This R package uses the Quandl API. For more information go to \url{https://www.quandl.com/docs/api}. For more help on the package itself go to \url{https://www.quandl.com/help/r}.
#' @export
get.marketData <- function(code, start_date, end_date,
collapse=c("daily", "weekly", "monthly", "quarterly", "annual"),
api_key, skipNullStocks = FALSE, skipNA = FALSE) {
# check if code is correct
if (!all(gsub("[^A-Z0-9_.]", "", code) == code)) {
stop("Codes are comprised of capital letters, numbers and underscores only.")
}
# convert freq to interger. Used in skipNA=TRUE to validate if data.frame is of complete form.
frequency2integer <- function(freq) {
if (is.null(freq) || is.na(freq)) {
return(252)
} else {
switch(freq,
"daily"    = 252,
"weekly"   = 52,
"monthly"  = 12,
"quarterly" = 4,
"yearly"   = 1,
1)
}
}
# setup params for GET request
params <- list()
params$collapse <- match.arg(collapse)
params$start_date <- as.Date(start_date, format = "%Y-%m-%d")
params$end_date <- as.Date(end_date, format = "%Y-%m-%d")
params$end_date <- end_date
params$api_key <- api_key
params$column_index <- 11
params$transform <- "rdiff"
missingCodes <- c()
tempRes <- NULL
for (c in code) {
df <- get.dataset(c, params, skipNullStocks)
# check if a dataset has been found
if (is.null(df)) {
missingCodes <- append(missingCodes, c)
next()
}
# skipNA=TRUE, check if frequency of dataset returned is correct
if (!(length(df[, 2] & skipNA == TRUE) == frequency2integer(params$collapse))) {
missingCodes <- append(missingCodes, c)
next()
}
# merge data.frames
if (is.null(tempRes)) {
tempRes <- df
} else {
tempRes <- merge(tempRes, df, by = "date", all = TRUE)
}
}
return(list("data"=tempRes, "missingCodes"=missingCodes))
}
get.dataset <- function(code, params, skipNullStocks) {
writeLines(sprintf("Calling %s data...", code))
json <- api.call(url_base=sprintf("https://www.quandl.com/api/v3/datasets/WIKI/%s/data.json?", code),
params=params)$dataset
if (length(json$data) == 0) {
if (skipNullStocks == FALSE) {
stop(sprintf("Data for %s between %s and %s (%s) does not exists.",
code, params$start_date, params$end_date, params$collapse))
} else {
writeLines(sprintf("Data for %s between %s and %s (%s) does not exists.",
code, params$start_date, params$end_date, params$collapse))
return(NULL)
}
}
fin_data <- data.frame(json$data, stringsAsFactors = FALSE)
names(fin_data) <- c("date", code)
fin_data[, 1] <- as.Date(fin_data[, 1])
fin_data[, 2] <- as.numeric(fin_data[, 2])
return(fin_data)
}
api.call <- function(url_base, params) {
response <- httr::GET(url_base, query=params)
if (!(httr::status_code(response) >= 200 && httr::status_code(response) < 300)) {
stop(httr::content(response, as = "text"), call. = FALSE)
}
text_response <- httr::content(response, as = "text")
json_response <- tryCatch(jsonlite::fromJSON(text_response, simplifyVector = TRUE), error = function(e) {
stop(e, " Failed to parse response: ", text_response)
})
return(json_response)
}
get.marketData.random <- function(ncode, start_date, end_date,
collapse=c("daily", "weekly", "monthly", "quarterly", "annual"),
api_key, excludedCodes = NULL, skipNA = TRUE, recursive=FALSE) {
# Function needed for recursive option
recursive.helper <- function(df, codes.random, start_date, end_date, collapse, api_key) {
rec.data.random <- get.marketData(code = codes.random, start_date = start_date, end_date = end_date,
collapse = collapse, api_key = api_key, skipNA = skipNA, skipNullStocks = TRUE)
df <- tryCatch(
{
merge(df, rec.data.random$data, by="date", all = TRUE)
},
error=function(e) {
message(e)
message(names(rec.data.random$data))
message(names(df))
message(codes.random)
message(rec.data.random$missingCodes)
stop()
},
finally={df})
return(list("data"=df, "missingCodes"=rec.data.random$missingCodes))
}
# Remove codes that should not be included in sample
remove.codes.subset <- function(codes, codes2remove) {
return(subset(codes, !(codes %in% codes2remove)))
}
if (ncode > 299) {
stop("Max allowed number of requests is 299 per 10 seconds.")
}
codes <- read.table("metadata/tickers", header = TRUE, stringsAsFactors = FALSE)$code
codes <- remove.codes.subset(codes, excludedCodes)
codes.random <- sample(codes, ncode)
data.random <- get.marketData(code = codes.random, start_date = start_date, end_date = end_date,
collapse = collapse, api_key = api_key, skipNA = skipNA, skipNullStocks=TRUE)
# If none of stocks has been found - run the function again.
if (is.null(data.random$data)) {
get.marketData.random(ncode, start_date, end_date, collapse, api_key, excludedCodes, recursive)
}
if (is.null(data.random$missingCodes)) {
return(data.random)
}
if (recursive == TRUE) {
codes <- remove.codes.subset(codes, data.random$missingCodes)
codes.random <- sample(codes, length(data.random$missingCodes))
data.random$missingCodes <- NULL
while (TRUE) {
data.random <- recursive.helper(data.random$data, code = codes.random, start_date = start_date,
end_date = end_date, collapse = collapse, api_key = api_key)
if (!is.null(data.random$missingCodes)) {
codes <- remove.codes.subset(codes, data.random$missingCodes)
codes.random <- sample(codes, length(data.random$missingCodes))
} else {
return(data.random)
}
}
}
}
for (i in c(1:15)) {dt.rand <- get.marketData.random(10, start_date = start_date, end_date = end_date, collapse = "weekly", token, recursive = TRUE)
print(i)
}
#' End of day US Stock Proces
#'
#' Retrieves Data from the Quandl Dataset endpoint and formats
#' @param code string or list of strings: Code a.k.a ticker symbol on Quandle.
#' @param start_date A Date object, format="YYYY-MM-DD". Retrieve data rows on and after the specified start date.
#' @param end_date A Date object, format="YYYY-MM-DD". Retrieve data rows up to and including the specified end date.
#' @param collapse Change the sampling frequency of the returned data. Default is none; i.e., data is returned in its original granularity.
#' @param api_key Authentication toket for a Quandl user.
#' @param skipNA If FALSE, STOP is a code for a predefined date range is not found, otherwise WARNIGN. Default=FALSE
#' @return list(data=dataframe of returns per stock, missingCode=vector of codes that do not satisfy input params)
#' @examples \dontrun{
#' code <- c("AAPL", "FB", "GOOG", "C", "A", "INTC", "T", "WMT", "TXN")
#' start_date <- "2017-12-31"
#' end_date <- "2018-12-31"
#' collapse <- "daily"
#' api_key <- "User123"s
#' market_date <- get.marketDate (code=code, start_date=start_date, end_date=end_date, collapse=collapse, api_key=api_key)
#' }
#' @note Due to Quandle database specification, all ".", " " symbols are represented as "_".
#' @references This R package uses the Quandl API. For more information go to \url{https://www.quandl.com/docs/api}. For more help on the package itself go to \url{https://www.quandl.com/help/r}.
#' @export
get.marketData <- function(code, start_date, end_date,
collapse=c("daily", "weekly", "monthly", "quarterly", "annual"),
api_key, skipNullStocks = FALSE, skipNA = FALSE) {
# check if code is correct
if (!all(gsub("[^A-Z0-9_.]", "", code) == code)) {
stop("Codes are comprised of capital letters, numbers and underscores only.")
}
# convert freq to interger. Used in skipNA=TRUE to validate if data.frame is of complete form.
frequency2integer <- function(freq) {
if (is.null(freq) || is.na(freq)) {
return(252)
} else {
switch(freq,
"daily"    = 252,
"weekly"   = 52,
"monthly"  = 12,
"quarterly" = 4,
"yearly"   = 1,
1)
}
}
# setup params for GET request
params <- list()
params$collapse <- match.arg(collapse)
params$start_date <- as.Date(start_date, format = "%Y-%m-%d")
params$end_date <- as.Date(end_date, format = "%Y-%m-%d")
params$end_date <- end_date
params$api_key <- api_key
params$column_index <- 11
params$transform <- "rdiff"
missingCodes <- c()
tempRes <- NULL
for (c in code) {
df <- get.dataset(c, params, skipNullStocks)
# check if a dataset has been found
if (is.null(df)) {
missingCodes <- append(missingCodes, c)
next()
}
# skipNA=TRUE, check if frequency of dataset returned is correct
if (!(length(df[, 2] & skipNA == TRUE) == frequency2integer(params$collapse))) {
missingCodes <- append(missingCodes, c)
next()
}
# merge data.frames
if (is.null(tempRes)) {
tempRes <- df
} else {
tempRes <- merge(tempRes, df, by = "date", all = TRUE)
}
}
return(list("data"=tempRes, "missingCodes"=missingCodes))
}
get.dataset <- function(code, params, skipNullStocks) {
writeLines(sprintf("Calling %s data...", code))
json <- api.call(url_base=sprintf("https://www.quandl.com/api/v3/datasets/WIKI/%s/data.json?", code),
params=params)$dataset
if (length(json$data) == 0) {
if (skipNullStocks == FALSE) {
stop(sprintf("Data for %s between %s and %s (%s) does not exists.",
code, params$start_date, params$end_date, params$collapse))
} else {
writeLines(sprintf("Data for %s between %s and %s (%s) does not exists.",
code, params$start_date, params$end_date, params$collapse))
return(NULL)
}
}
fin_data <- data.frame(json$data, stringsAsFactors = FALSE)
names(fin_data) <- c("date", code)
fin_data[, 1] <- as.Date(fin_data[, 1])
fin_data[, 2] <- as.numeric(fin_data[, 2])
return(fin_data)
}
api.call <- function(url_base, params) {
response <- httr::GET(url_base, query=params)
if (!(httr::status_code(response) >= 200 && httr::status_code(response) < 300)) {
stop(httr::content(response, as = "text"), call. = FALSE)
}
text_response <- httr::content(response, as = "text")
json_response <- tryCatch(jsonlite::fromJSON(text_response, simplifyVector = TRUE), error = function(e) {
stop(e, " Failed to parse response: ", text_response)
})
return(json_response)
}
get.marketData.random <- function(ncode, start_date, end_date,
collapse=c("daily", "weekly", "monthly", "quarterly", "annual"),
api_key, excludedCodes = NULL, skipNA = TRUE, recursive=FALSE) {
# Function needed for recursive option
recursive.helper <- function(df, codes.random, start_date, end_date, collapse, api_key) {
rec.data.random <- get.marketData(code = codes.random, start_date = start_date, end_date = end_date,
collapse = collapse, api_key = api_key, skipNA = skipNA, skipNullStocks = TRUE)
if (!(is.null(rec.data.random$data))) {
df <- merge(df, rec.data.random$data, by="date", all = TRUE)
}
return(list("data"=df, "missingCodes"=rec.data.random$missingCodes))
}
# Remove codes that should not be included in sample
remove.codes.subset <- function(codes, codes2remove) {
return(subset(codes, !(codes %in% codes2remove)))
}
if (ncode > 299) {
stop("Max allowed number of requests is 299 per 10 seconds.")
}
codes <- read.table("metadata/tickers", header = TRUE, stringsAsFactors = FALSE)$code
codes <- remove.codes.subset(codes, excludedCodes)
codes.random <- sample(codes, ncode)
data.random <- get.marketData(code = codes.random, start_date = start_date, end_date = end_date,
collapse = collapse, api_key = api_key, skipNA = skipNA, skipNullStocks=TRUE)
# If none of stocks has been found - run the function again.
if (is.null(data.random$data)) {
get.marketData.random(ncode, start_date, end_date, collapse, api_key, excludedCodes, recursive)
}
if (is.null(data.random$missingCodes)) {
return(data.random)
}
if (recursive == TRUE) {
codes <- remove.codes.subset(codes, data.random$missingCodes)
codes.random <- sample(codes, length(data.random$missingCodes))
data.random$missingCodes <- NULL
while (TRUE) {
data.random <- recursive.helper(data.random$data, code = codes.random, start_date = start_date,
end_date = end_date, collapse = collapse, api_key = api_key)
if (!is.null(data.random$missingCodes)) {
codes <- remove.codes.subset(codes, data.random$missingCodes)
codes.random <- sample(codes, length(data.random$missingCodes))
} else {
return(data.random)
}
}
}
}
for (i in c(1:15)) {dt.rand <- get.marketData.random(10, start_date = start_date, end_date = end_date, collapse = "weekly", token, recursive = TRUE)
print(i)
}
getwd()
library(MarkowitzUW)
res <- c()
for (i in c(1:10)) {
dt.rand <- get.marketData.random(10, start_date = start_date, end_date = end_date, collapse = "weekly", token,
recursive = TRUE)$data
print(length(dt.rand))
row.names(dt.rand) <- data.random$date
dt.rand$date <- NULL
print(length(dt.rand))
sharp <- sharpRation.optimization.GP(dt.rand)
res <- append(res, sharp)
}
res <- c()
for (i in c(1:10)) {
dt.rand <- get.marketData.random(5, start_date = start_date, end_date = end_date, collapse = "weekly", token,
recursive = TRUE)$data
print(length(dt.rand))
row.names(dt.rand) <- data.random$date
dt.rand$date <- NULL
print(length(dt.rand))
sharp <- sharpRation.optimization.GP(dt.rand)
res <- append(res, sharp)
}
get.marketData.random(15, start_date, end_date, "weekly", token, recursive=T)
for (i in c(1:20)) {
dt.rand <- get.marketData.random(5, start_date = start_date, end_date = end_date, collapse = "weekly", token,
recursive = TRUE)$data
print(length(dt.rand))
row.names(dt.rand) <- dt.rand$date
dt.rand$date <- NULL
print(length(dt.rand))
sharp <- sharpRation.optimization.GP(dt.rand)
res <- append(res, sharp)
}
res
